<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta http-equiv="Content-Language" content="en-us">
<title>ECE 4760 Precision Cooker: A Temperature Controlled Cooker </title>
    <link rel="stylesheet" type="text/css" media="all" href="./ECE4760_cooker_files/cornell_main.css">
    <link rel="stylesheet" type="text/css" media="all" href="./ECE4760_cooker_files/cornell_1column.css">
    <link rel="stylesheet" type="text/css" media="all" href="./ECE4760_cooker_files/main.css">
<link rel="shortcut icon" href="http://people.ece.cornell.edu/land/courses/ece4760/FinalProjects/f2013/cm522_iap9/cm522_iap9/cm522_iap9/Images/favicon.ico" type="image/x-icon">
<meta name="author" content="Gary He, Alex Maass">
<meta name="copyright" content="Copyright (c) 2013 Gary He, Alex Maass">
<meta name="description" content="Precision Cooker: A Temperature Controlled Cooker.">
<meta name="keywords" content="ECE, Cornell, 4760, Gary He, Alex Maass, Microcontrollers">
<style type="text/css"></style><style type="text/css"></style></head>
<body>

<div id="header">
  <!-- The following div contains the Cornell University logo and search link -->
  <div id="cu-identity"> 
		<div id="cu-logo"> 
			<a href="http://www.ece.cornell.edu/"><img src="./ECE4760_cooker_files/cu_logo.gif" alt="Cornell University" width="340" height="75" border="0"></a> 
		</div> 
  </div>
  <div class="linklist"> <a name="top"></a> </div>
  <!-- The search-form div contains a form that allows the user to search 
		either pages or people within cornell.edu directly from the banner.	-->
  <div id="search-form">
    <form action="http://www.cornell.edu/search/" method="get" enctype="application/x-www-form-urlencoded">
      <div id="search-input">
        <label for="search-form-query">SEARCH:</label>
        <input type="text" id="search-form-query" name="q" value="" size="20">
        <input type="submit" id="search-form-submit" name="submit" value="go">
      </div>
      <div id="search-filters">
        <input type="radio" id="search-filters1" name="tab" value="" checked="checked">
        <label for="search-filters1">Pages</label>
        <input type="radio" id="search-filters2" name="tab" value="people">
        <label for="search-filters2">People</label>
        <a href="http://www.cornell.edu/search/">more options</a> </div>
    </form>
  </div>
</div>
<div id="mainnav">
  <ul>
    <li><a href="index.html#design">High&nbsp;Level&nbsp;Design</a></li>
    <li><a href="index.html#hardware">Hardware</a></li>
    <li><a href="index.html#software">Software</a></li>
    <li><a href="index.html#results">Results</a></li>
    <li><a href="index.html#conclusions">Conclusions</a></li>
    <li><a href="index.html#appendices">Appendices</a></li>
  </ul>
</div>
<!-- end mainnav -->
<!-- end header -->
<div id="sectiontitle">
  <h4><a href="http://people.ece.cornell.edu/land/courses/ece4760/">ECE 4760</a>: <a href="http://people.ece.cornell.edu/land/courses/ece4760/FinalProjects/">Final Project</a></h4>
  <h1>Precision Cooker: A Temperature Controlled Cooker</h1>
  <h3>Gary He(<a href="mailto:gh269@cornell.edu">gh269<!--REMOVE--> at <!--REMOVE-->cornell.edu</a>)</h3>
  <h3>Alex Maass (<a href="mailto:am838@cornell.edu">am838<!--REMOVE--> at <!--REMOVE-->cornell.edu</a>)</h3>
</div>
<div id="wrapper">
  <div id="content">
    <div id="maincontent" class="hub">
    
      <div id="introblurb">
      <p>
  Precise time and temperature control are critical when cooking. Slight deviations in either temperature or cooking time can ruin delicate ingredients. Despite this fact, most modern day stovetops provide no data regarding their current temperatures and do not have built in timers. The stovetops that do provide these functionalities are often expensive and require specialized cookware. As our final project for ECE 4760 at Cornell University, we decided to build a programmable temperature and time controlled cooker that would use traditional thermal conduction to cook food regardless of the cooking vessel’s material. The cooker can be used for a variety of purposes ranging from simply boiling the perfect 6-minute soft-boiled egg to sous-vide cooking a piece of delicate white fish. Quickset options can be programmed into the cooker allowing for easy preset operation.
      </p>
  
      
      <div class="image"> <a href="./ECE4760_cooker_files/full_cooker.png"><img src="./ECE4760_cooker_files/full_cooker.png"></a>
        <p class="caption">The Precision Cooker</p>
        </div>
      <div class="image"> <a href="./ECE4760_cooker_files/delicious.jpg"><img src="./ECE4760_cooker_files/delicious.jpg"></a>
        <p class="caption">Delicious Results</p>
        </div>
      <div class="linklist"> <a name="design"></a>
        <h2>High Level Design &nbsp;&nbsp;&nbsp;<font size="-1"><strong><a href="index.html">top</a></strong></font></h2>
        <h3>Overview</h3>
        <p>
        Our aim for this project was to make temperature controlled cooking accessible to those without culinary training and/or professional kitchen appliances. Our project focuses on immersion cooking methods such as poaching, simmering, boiling, or sous vide cooking. We decided to focus on these cooking methods as they require very little technique but rather precise temperature control and cooking time. Recipes often call for specific temperatures and timings, but as most modern-day stovetops provide no temperature or timing feedback, it is difficult to know when these requirements have been met. By being able to set precise timings and temperatures, users simply have to place the food in the cooker when prompted and let the cooker handle the rest in order to create a perfectly cooked dish.</p>
	<h4>Rationale and Motivation Behind our Project</h4>
        <p>
      Cooking foods at controlled temperatures is a very difficult thing to achieve for extended periods of time. Using traditional gas stovetops, it is almost impossible to maintain a specific temperature for a set amount of time. However, by controlling the heat source electronically using a feedback loop, we can continuously measure the temperature and adjust it as necessary. Our project is designed to maintain any temperature between 45 and 100 degrees Celsius for extended periods of time with minimal deviation in temperature.
      </p>

<h4>Background Math</h4>
  <p>
  For background math, we will be discussing our PID controller and our voltage-temperature sensor calibration and equation derivation. 
    For our temperature control feedback loop, we utilized a proportional-integral-derivative (PID) controller. The PID controller measures the deviation between the desired result and the current measurement and outputs a value that is calibrated to reach the desired value with minimal overshoot or undershoot. Our PID controller is sourced from the AVR221 application. The PID controller is composed of three terms: the proportional term, integral term, and derivative term. These three terms are summed together to calculate the output of the PID controller. The PID equation is defined as: 
  </p>
  <div class="image"> <img src="./ECE4760_cooker_files/pid_equation.PNG">
  </div>

  <p>
where:
  <ul>
    <li>K<sub>p</sub> : Proportional term</li>
    <li>K<sub>i</sub> : Integral term</li>
    <li>K<sub>d</sub> : Derivative term</li>
    <li>e : Error term</li>
    <li>t : Time of measurement</li>
    <li>&tau; : Integration variable ( 0 -> t)</li>
  </ul>
</p>
 
 <p> 
For our final PID values, we selected P = .07, I = .04, and D = .05. All of these values are low as our system changes very slowly and adjustments to the system take a long time to take effect due to the high specific heat of our immersion liquid (water). 

For our voltage-temperature sensor calibration, we utilized the LM35 temperature sensor to measure the temperature of the immersion liquid. The LM35’s datasheet provided us with the below voltage-temperature curve. 
  </p>

 <div class="image"> <img src="./ECE4760_cooker_files/provided_vt_curve.png">
          <p class="caption">Figure 1: Stock LM35 voltage temperature curve</p>
  </div>
<p>
  After some experimentation, we discovered that the given curve did not fit our measured results. To properly calibrate our temperature readings we swept across numerous temperatures and measured the voltage output of the LM35 using the microcontroller’s built in ADC. We then plotted these values and performed linear regression to find a line of best fit that we used as our voltage-temperature equation
</p>
 <div class="image"> <img src="./ECE4760_cooker_files/temperature_adc_fitting.png">
          <p class="caption">Figure 2: Measured Temperature-ADC Voltage Curve</p>
  </div>

 <div class="image"> <img src="./ECE4760_cooker_files/temperature_adc_relation.png">
  </div>

<h4>Logical Structure</h4>
<p>
Our project is composed of three discrete modes of operation: input, heating, and cooking. These stages are further split into smaller states for implementation purposes. These smaller states can be seen in the software finite state machine shown in Figure 10. 
</p>
<p>
  During input mode, the heating element remains off and the system waits for user input. During this mode, the temperature desired and the cooking time should be set using either the three analog knobs or the UART computer interface. Once the temperature and cooking time are set, the system waits for the mode switch to be moved from off to on. Once the switch is moved to the on state, the system stores the desired temperature and cooking time and transitions into heating mode.
</p>
<p>
  During heating mode, the cooker’s heating element heats up the cooking vessel to the desired temperature. During heating mode it is possible to switch between the LED display showing current temperature and desired temperature by toggling the display mode switch. The microcontroller controls the cooker by reading the temperature probe submerged in the cooking liquid and switching the relay inside the power box. When the relay is switched on, the cooker’s heating element is connected to the main power line and current flows through the heating element. This current flow causes the heating element to heat up. Through thermal conduction, both the cooking vessel and the cooking liquid begin to heat up as well. Once the desired temperature has been reached in the cooking liquid, the relay is turned off and a buzzer sounds. This buzzer signals the user that food should be placed into the cooker as the desired temperature has been reached. The cooker then transitions into cooking mode. 
</p>
<p>
In cooking mode, the cooker begins to count down the desired cooking time recorded during input mode. During this mode, the cooking vessel will maintain the desired temperature by turning on and off the relay according to the readings from the immersed temperature probe. The cooker counts down until the timer reaches 0 and then a buzzer goes off to signal the user that the food has finished cooking. The buzzer continues to sound until the mode switch is set to input mode. At this point the cooker moves back into input mode to wait for further instructions. If the desired cooking time is left at 0, the system will beep immediately. 
</p>


<h4>Hardware and Software Tradeoffs</h4>
<p>
  In our hardware design, we decided to increase the hardware complexity by adding analog potentiometers for setting the temperature and time and building our own LED display screen. While we could have used an LCD display to display temperature and cooking time information, we decided to build our own LED display as it allowed us to print to a larger font. Despite the LED display being very difficult to build and program, it provides a larger and brighter display compared to the LCD display. We decided to implement analog potentiometers for setting the temperature and cooking time so that the system could be used independently of the UART computer interface. While our cooker can be programmed using the serial UART connection to a PC, it can also operate independently using only the analog potentiometers. 
</p>

<p> 
  In our software design, we decided to use the Tiny Real Time (TRT) kernel written by Dan Henriksson and Anton Cervin as it allowed us to easily schedule tasks at set intervals and synchronize variables across multiple tasks. While using the TRT kernel decreased the amount of flexibility we had in writing our software, it ultimately made scheduling software tasks a lot easier.  
</p>
        
<h4>Relevant existing patents, copyrights, and trademarks</h4>
 <p>
      There are no existing patents, copyrights or trademarks that our project infringes on. While numerous patents exist regarding temperature controlled cookers (e.g Patent EP2661944 A2 & Patent WO2012092683 A3), they utilize inductive heating surfaces which we do not use. The patent closest to our design that we found was Patent CA2722383 A1 which describes a temperature controlled heating element. However, this patent still does not apply to our project as it describes controlling the heating element’s temperature using electrical sensors within the heating coil while our system measures the temperature of the food’s immersion liquid.  
We utilize the Tiny Real Time (TRT) kernel and its supplemental UART libraries, both of which are filed under the “Beer-Ware License" by Joerg Wunsch. We also utilize the generic PID Controller code created by Atmel for the AVR221 application. 

</p>
 
       <div class="linklist"> <a name="hardware"></a>
        <h2>Hardware &nbsp;&nbsp;&nbsp;<font size="-1"><strong><a href="index.html">top</a></strong></font></h2>
<p>
  Our overall hardware design is composed of numerous subsystems. The various subsystems can be seen in the figure below. 
</p>
 <div class="image"> <img src="./ECE4760_cooker_files/hardware_subsystem_block_diagram.png">
          <p class="caption">Figure 3: Hardware subsystem block diagram.</p>
  </div>
<p>The following subsystems compose our overall system:</p>
<ul>
<li> Atmel Atmega 1284P Microcontroller </li>
<li> Analog Inputs</li>
<li> Buzzer Sound Subsystem</li>
<li> LED Display</li>
<li> Temperature Sensor</li>
<li> Power Supply and Heating Element</li>
</ul>

<h4>Microcontroller</h4>
<p>
Our microcontroller, an Atmel Atmega 1284P, is the logic controller of our system. Our microcontroller is mounted on a custom PCB produced by Professor Bruce Land of Cornell University. In addition to the microcontroller, the PCB includes an external oscillator, voltage regulators, and a FTDI serial module. The majority of the microcontroller’s functionality will be covered under the software design section. The microcontroller performs the following functions:
</p>

<ul>
<li> Controls the power supply relay to turn on and off the heating element.</li>
<li> Reads the temperature probe and calculates the current temperature. </li>
<li> Reads the analog inputs to correctly set the desired temperature and cooking time. </li>
<li> Turns on and off the piezoelectric buzzer.</li>
<li> Sends messages to display on the LED display.</li>
</ul>

 <div class="image"> <img src="./ECE4760_cooker_files/microcontroller_pcb_schematic.png" width="500">
          <p class="caption">Figure 4: Microcontroller PCB schematic</p>
  </div>

<h4>Buzzer Sound System</h4>
<p>
Our piezoelectric buzzer, a CET12A35, is connected to a TI 296-6501-1-ND 555 timer that is wired to oscillate at 1 KHz. The output of the 555 timer is connected to the gate of an nMOS transistor that has its drain connected to VCC and its source connected to the drain of another nMOS transistor. The gate of the second nMOS transistor is connected to the microcontroller and the source is connected to the first terminal of the piezoelectric buzzer. The second terminal of the piezoelectric buzzer is connected to ground. The 555 timer switches the first nMOS transistor at a 1KHz frequency and allows the source to have full VCC-GND voltage swing. This signal is then gated by the signal from the microcontroller. If the microcontroller sets the buzzer control signal high, the second nMOS transistor will turn on and the piezoelectric buzzer will convert the square signal produced by the 555 timer to audible sound. 
</p>
 <div class="image"> <img src="./ECE4760_cooker_files/speaker.png" width="500">
          <p class="caption"> Figure 5: Buzzer sound system hardware schematic.</p>
  </div>
<h4>Heating Element and Power Supply</h4>
<p>
Our heating element and power supply subsystem is composed of a power box and a resistive heating element. The power box controls the current and voltage received by the heating element. The power box consists of a 2 way gang box with a duplex electrical outlet, a single pole electrical switch, and a high current relay module. For there to be an electrical connection between the electrical outlets built into the gang box and the main power lines, both the relay and the single pole electrical switch must be turned on. The electrical switch is the first line of protection that the user must physically switch on. Once the electrical switch is switched on, the relay controls the connection between the electrical outlets and the mains. The relay is controlled by three wires: VCC, GND, and EN. The VCC and GND pins are connected to the USB VCC and GND pins of the microcontroller. We initially connected VCC to the VCC port on the microcontroller, but we found that the large current spike of the relay during switching would lower the voltage of the VCC rail and result in improper operation of other devices connected to the microcontroller’s VCC rail, such as the temperature sensor. The relay is an active low device and will remain off unless its EN signal is pulled low by the microcontroller. By default, the microcontroller sets the EN signal to high. If the EN signal is set to floating, the relay will still not turn on. With both the relay and single pole switch turned on, a connection is made between the heating element and the main power rail. With this connection enabled, the heating element begin heating up. This generated heat is transferred to the cooking vessel by thermal conduction which in turn is transferred to the immersion liquid. 
</p>
<p>
Our heating element and chassis was sourced from an old Panasonic rice cooker. We stripped the rice cooker of all parts and kept only the metallic shell and the 400W resistive heating element. We had initially planned to replace the 400W heating element with a more powerful 1000W heating element sourced from a hot water heater, but due to thermal conduction issues we settled with the 400W heating element for our final design. 
</p>
 <div class="image"> <img src="./ECE4760_cooker_files/gangbox.png" width="500">
          <p class="caption">Figure 6: Power box and heating element hardware schematic.</p>
  </div>
<h4>Temperature Sensor and Analog Inputs</h4>
<p>
Our temperature sensor is a LM35 solid state temperature sensor. It is connected to the microcontroller by three pins: VCC, GND, and OUT. The VCC and GND pins are connected to the VCC and GND pins of the microcontroller. The OUT signal is connected to port A0 and is read by the internal ADC of the microcontroller. Since the OUT signal changes according to the temperature that the LM35 detects, the ADC is continuously polled every 4 seconds. 
</p>
<p>
Three potentiometers and two slide switches provide user input to our cooker. The potentiometers are read using the ADC on PORTA and converted to digital values which are interpreted on software. Two types of potentiometers are used. 500 Ohm potentiometers are used for the minutes and seconds knobs. While these provide relatively coarse grained control, the wipers on these potentiometers are very smooth and give good user feedback. A 10K pot is used for precise control of temperature because fine grained temperature control is critical for our application.
</p>
 <div class="image"> <img src="./ECE4760_cooker_files/analog_input.png" width="500">
          <p class="caption"> Figure 7: Analog potentiometers and switches hardware schematic.</p>
  </div>

 <h4>LED Display</h4>
 <p>
  The LED display is made of a pair of E3005 common anode 8 by 8 LED matrices for a total screen width of 16 columns by 8 rows. The display is row scanned with a separate 8 stage 74HC164N SIPO shift register addressing each display. The microcontroller scans each row of the combined display and turns on each row of the 16 column display for the shift register to drive. Before each row is turned on, values are clocked into the shift registers at 1 MHz before we pull a row low and drive the display with the shift register. Rows are scanned at 50 KHz. Figure 5 illustrates the connections from the LED displays to the microcontroller’s PORTD.
 </p> 
 <div class="image">
  <a href="./ECE4760_cooker_files/screens_full.png"> 
          <img src="./ECE4760_cooker_files/screens_full.png" width="500">
  </a>
          <p class="caption">Figure 8: Wiring schematic for LED Display. Click to Enlarge</p>
  </div>
</div>
<div class="linklist"> <a name="software"></a>
  <h2>Software &nbsp;&nbsp;&nbsp;<font size="-1"><strong><a href="index.html">top</a></strong></font></h2>
<h4>Software Design</h4>
<p>
  We devised a common interface so that each software subsystem could be worked on independently but still be integrated easily with minimal modifications. As a result, a lot of code is encapsulated into structs. Our software design is composed of the following subsystems:
</p>
<ul>
<li>State Control FSM</li>
<li>Writing to the LED Display</li>
<li>Temperature Measurement and PID Adjustment</li>
<li>Input Reading</li>
</ul>
<p>
Each system is implemented in a separate file and tied together with header files and common interface methods. Below is a high level description of each subsystem and main function listing.
</p>

<h4>State Control Finite State Machine <em>(fsm.h)</em> </h4>
 <div class="image">
  <a href="./ECE4760_cooker_files/fsm.png"> 
          <img src="./ECE4760_cooker_files/fsm.png" width="500">
  </a>
          <p class="caption">Figure 9: State Control Finite State Machine (FSM). Click to Enlarge</p>
  </div>
<p>
Our cooker is controlled by the FSM described above. The FSM takes into account user input and the current state of the cooker. The following composes our FSM implementation. 
</p>
<h5><em>write_state_message_on_buffer()</em></h5>
<p>
Sets up the LED display for a different display mode depending on the current state of the FSM. The LED can display the temperature, time, cooking status or display a neutral smile.
</p> 
<h5><em>handle_next_state_logic()</em></h5>
<p>
Stores input values such as desired temperature or desired cooking time into operational variables. This includes turning on/off the buzzer when the cooker has reached the desired temperature and cooking time, saving the desired temperature or saving the cooking time. 
</p> 
<h5><em>state_transition_logic()</em></h5>
<p>
The control table that implements the state transitions for our Moore machine. Data from all the available input methods impact which state transition to take. The control table can be found in our source code.
</p>

<h4>Writing to the LED Display  <em>(screen.c, screen.h)</em> </h4>
<p>
Writing to a 16 by 8 LED matrix was non-trivial considering how few pins we had available on our microcontroller. This was accomplished by shifting bits serially to a SIPO shift register which would drive the LED display through row scanning.  
</p>

<h5><em>write_to_buffer(int * left_valueR, int * left_valueL, int * right_valueR, int * right_valueL)</em></h5>
<p>
Stores screen data in a temporary buffer in preparation for writing to the screen. This buffer is a complete copy of what is displayed on the LED display. 
</p>

<h5><em>write_buffers_to_screen()</em></h5>
<p>
Writes the values stored in the buffer by serially sending bits to the shift registers that control the shift registers. When writing to the shift registers, our data clocks shifts at 1 MHz. To save power, when we are not shifting, the shift register clock is turned off. The LED screens are row scanned at around 50 KHz.
</p>

<h5><em>write_happy_to_buffer();</em></h5>
<h5><em>write_empty_to_buffer();</em></h5>
<h5><em>write_temp_to_buffer(int temp_celsius);</em></h5>
<h5><em>write_min_to_buffer(int min);</em></h5>
<h5><em>write_time_to_buffer(int total_seconds);</em></h5>
<p>
These functions are a sampling of the various display modes that our LED display supports. Each function extends write_to_buffer by including functionality to convert human readable values into the bit arrays that populate the screen.
</p>


<h4>Input Reading and Debouncing <em>(analog_input.c, analog_input.h, input_db.h)</em></h4>
<p>
These files contain the ANALOG INPUT struct and associated utilities to read and update the struct. ANALOG INPUT centralizes the reading and updating of all the potentiometers we use as dials in the user interface. Centralizing the analog input was a key factor in making our code modular and streamlining our development process. Prototyping was done with the UART serial input but our final design included all 3 analog dials. Centralizing the inputs made integration easier and cut development time because the subsystems could be tested independently and integrated as long as a common interface was followed. This common interface is embodied in struct members and methods. Analog input is read in from the ADC and linearly scaled from the 0-1023 range that the potentiometers provide to human readable ranges such as 0-99 for minutes, 0-59 for seconds, or 0-100 degrees Celsius for temperature. 
<p>

<h5><em>analog_input_init(struct ANALOG_INPUT * t)</em></h5>
<h5><em>analog_input_update(struct ANALOG_INPUT * t)</em></h5>
<p>
Functions that create and update analog input values through the ADC. 
</p>
<h5><em>pot_to_temp(int value)</em></h5>
<h5><em>pot_to_minutes(int value)</em></h5>
<h5><em>pot_to_seconds(int value)</em></h5>
<p>
The utility functions that convert potentiometer values into human readable values. Each function performs a simple linear scaling from the potentiometer’s input range to the desired output range. 
</p>

<h5><em>seconds_changed(struct ANALOG_INPUT * t)</em></h5>
<h5><em>minutes_changed(struct ANALOG_INPUT * t)</em></h5>
<h5><em>temperature_changed(struct ANALOG_INPUT * t)</em></h5>
<p>
Functions that use hysteresis to detect when the potentiometers change value. This is necessary because there is a jitter in ADC readings which gives a lot of false positives when moving the dials. These functions take care of identifying true changes in the potentiometer values.
</p>

<h4>Temperature Measurement and PID Adjustment <em>(main.c, pid.c, pid.h)</em></h4>
<p>
Much like the ANALOG INPUT struct is used in reading analog input values, the PID DATA struct is used to read and adjust the PID controller. Again, this allowed us to work concurrently and integrate our parts at a later time. Centralizing PID into its own struct allowed us to separate the control logic from the pertinent details of the PID algorithm. 
</p>

<h5><em>pid_Init(double p, double i, double d, struct PID_DATA *p)</em></h5>
<h5><em>double pid_Controller(int target, int current_value, struct PID_DATA *p)</em></h5>
<p>
Instantiate the PID control algorithm in a self-contained struct. The main file gets control values from the PID struct to decide whether or not to enable the relay. 
</p>
<h5><em>adjustTemp(void* args)</em></h5>
<p>
TRT Task dedicated to making fine adjustments to the temperature by turning on and off the relay. 
</p>
</div>
<div class="linklist"> <a name="results"></a>
    <h2>Results &nbsp;&nbsp;&nbsp;<font size="-1"><strong><a href="index.html">top</a></strong></font></h2>

<h4>Execution Speed</h4>
<p>
The speed of our program execution varies from task to task. Our slowest task, the temperature measurement reading, has a deadline of 4 seconds. This time was chosen as the specific heat of water is high and our immersion liquid is able to absorb a significant amount of heat before rising in temperature. By only polling the temperature sensor every 4 seconds, we reduce the amount of relay switching. Since the relay we chose for our project is a physical relay, it produces a loud switching noise when turning on or off. In the case where the current temperature is oscillating around the desired temperature, if the temperature sensor would be read and adjusted quickly, the relay could switch on and off at a very high rate and become a nuisance. 
</p>
<p>
  While our slowest task may have a deadline of 4 seconds, we also have numerous tasks that are never set to sleep and are continuously running. These include the serial communication task which prints to and reads from the UART and the LED display update task. As the image on the LED display is generated by quickly cycling through the columns of LEDs, our LED display task runs very quickly to produce a recognizable image. Based on our code, we cycle through a column of LEDs on the LED display every 24 milliseconds. 
</p>
      <div class="image"> <a href="./ECE4760_cooker_files/satisfied_customer.jpg"><img src="./ECE4760_cooker_files/satisfied_customer.jpg"></a>
        <p class="caption">A satisfied customer.</p>
        </div>
<h4>Accuracy</h4>
<p>
  Our cooker is surprisingly accurate in the temperature that it is able to maintain. For starters, our calibration function for converting the raw ADC input to degrees Celsius is accurate within 2 degrees when the temperature probe is immersed in water above 45 degrees Celsius. Since all of the cooking will be done at temperatures above 45 degrees Celsius, we calibrated our temperature probe to be especially accurate between 45 and 100 degrees Celsius.
</p>

<p>
In addition to our calibration function being accurate, our temperature feedback loop is also quite effective. Because our temperature readings are very accurate due to the aforementioned calibration function, we are able to turn off our heat source as soon as the temperature of the immersion liquid reaches our desired temperature. In addition, due to the carry over cooking effect that is present due to the large heating element, we actually shut off our heating element once the temperature of the immersion liquid reaches 95% of our desired temperature. From that point, we let the carry over effect continue to heat up the immersion liquid. By doing this, we prevent thermal overshoot, which is particularly difficult to deal with as our cooking vessel retains heat very well.   
</p>

<h4>Safety</h4>
<p>
  Since our project utilized main power lines as a power source, we were extremely aware of safety considerations. The power box that we built to supply power to our heating element contains both a relay and a discrete physical switch to prevent accidental turn on. For the first layer of protection, a discrete physical switch disconnects the output of the power box from the input mains. Only when the switch is turned on, does the second layer of protection become applicable. For our second layer of protection, we utilize an active low relay. By default, whether during microcontroller startup or if the control wire is left floating, the relay disconnects the main lines coming from the output of the switch to the output of the power box. Only when the control signal of the relay is actively pulled low does the relay turn on and allow a connection between the main power line and the output. During startup the microcontroller sets the control signal of the relay to high, thereby initializing the relay to be disconnected. By implementing both the physical switch and the relay as intermediaries between the output of the power box and the main power lines, we prevent as much accidental turn on as possible.  
</p>
<h4>Interference</h4>
<p>
  Our project does not interfere with other people’s designs. Since our system is a closed system, for the most part we do not need to take into account other people’s designs. 
</p>

<h4>Usability</h4>
<p>
  Our project is usable to both the technically adept and the technically challenged. For those that are technically challenged, we provide three clearly labeled analog dials that adjust the temperature, the minute timer, and the second timer. For the technically adept, we provide a UART computer interface to digitally program the desired temperature and time to cook. In addition, for those that are technically adept, we provide the source code to allow users to program in quickset cooking options for commonly cooked foods, such as eggs or noodles. While our final project may look complicated, the majority of user inputs are clearly labeled to allow all users a good experience in cooking their food. 
</p>

 </div>
    


<div class="linklist"> <a name="conclusions"></a>
  <h2>Conclusions &nbsp;&nbsp;&nbsp;<font size="-1"><strong><a href="index.html">top</a></strong></font></h2>
<h4>Results vs Expectations</h4>
<p>
  We were pleasantly surprised that the results of our project exceeded our expectations. Our initial design was to produce a simple temperature controlled cooker that would only be usable through the UART interface and would utilize a stock LCD screen for temperature and time remaining statistics. However, we managed to include additional hardware dials and switches to allow for programming of the device without a UART connection to a PC. In addition, we implemented a larger and brighter LED display that would display the temperature or time remaining depending on the switch settings. We feel that both of these inclusions makes our project more appealing to a variety of users and allows for operation in environments without a PC or technically skilled personnel. 
  In hindsight, there are a few changes that we would make regarding our design. For starters, we would have been more discerning in selecting a high powered heating element for our cooker. Our initial intention was to build a deep fat fryer that could achieve temperatures of up to 180 degrees Celsius, but due to a poorly selected heating element, we were forced to utilize the lower powered heating element that originally came with our rice cooker. In addition, we would have also been more discerning in the shift register that we selected to power our LED display. Due to poor shift register selection, we had to perform some high speed signal shifting on our microprocessor to correctly render images on the LED display. 
  To further iterate on this project, we anticipate including an automatic lift to place food into the cooker when the desired temperature has been reached and to remove the food once cooking has completed. This would improve our timing accuracy as the time required to place food into and remove food from the cooker would be constant across multiple uses and foods.
</p>
<h4>Applicable Standards</h4>
<p>
  As our temperature controlled cooker is derived from a rice cooker, it adheres to the standards set by the Electric Rice Cooker Criteria Standard Subcommittee, which is a subdivision of the Energy Efficiency Standards Subcommittee of the Advisory Committee on Energy and Natural Resources. The specifications can be found here:
http://www.eccj.or.jp/top_runner/pdf/tr_electric_rice_cooker.pdf
</p>
<h4>Intellectual Property Considerations</h4>
<p>
  To build our project we relied on both the hardware and software designs of others. For part selection, we based our temperature sensor and relay selection on the Sous-vide cooker project by Harrison Wong and David Diner. In our software, we employ heavy usage of the TRT kernel and its UART library which are licensable under the Beer-ware license by Joerg Wunsch. We also utilize the AVR221 Discrete PID Controller provided by Atmel.  
  For this project we did not attempt to reverse-engineer a design. Rather we took a commonly known design (temperature controlled induction cooktops) and applied the idea to standard conduction cooktops. We did not request sample parts for our project and therefore we were not required to sign a non-disclosure act. As the system design that we employed is relatively well known, it is highly unlikely that we would be able to patent or publish our design.  
</p>
<h4>Ethical Considerations</h4>
<p>
  Our product design and design process adheres to the IEEE Code of Ethics. Throughout the design of our project, we heavily considered safety when making design choices. We were adamant in ensuring that our power box would have multiple layers of electrical protection to prevent unwanted turn on of our heating element. We also insulated all high voltage electrical components with electrical tape to prevent any risk of a short circuit. In addition, we clearly labeled all plugs and have clear documentation regarding all high voltage wiring. Outside of successfully completing this project, we do not foresee any conflicts of interest, patent considerations or other intellectual property considerations.
</p>
<p>
  To the best of our ability we have documented our project and given credit to others where credit is due. We welcome any discussion to the contrary in the hopes that all disputes can be resolved and that the correct people receive due credit. 
  In addition to maintaining the IEEE Code of Ethics, we also factored in the Chef’s Code of Ethics set by the American Culinary Federation (http://www.acfchefs.org/download/documents/certify/certification/code_ethics.pdf). All results outputted by our project is done in good faith that our procedures and design choices are correct. We make no attempt to misrepresent our data. 
</p>
<h4>Legal Considerations</h4>
<p>
We maintain no responsibility for any unexpected consequences from building, using, or storing our project. We maintain no responsibility for any health effects caused by under or overcooked food using our device. We recommend that all food cooked in our cooker be not consumed and immediately discarded due to unknown possible side effects from ingestion.
</p>

</div>

      
      <div class="linklist"> <a name="appendices"></a>
        <h2>Appendices &nbsp;&nbsp;&nbsp;<font size="-1"><strong><a href="index.html">top</a></strong></font></h2>
        <h3>Source Code</h3>
<ul>
<li><a href="./code/"analog_input.c>analog_input.c</a> </li>
<li><a href="./code/"analog_input.h>analog_input.h</a> </li>
<li><a href="./code/"fsm.h>         fsm.h</a> </li>
<li><a href="./code/"main.c>        main.c</a> </li>    
<li><a href="./code/"pid.c>         pid.c</a> </li>
<li><a href="./code/"pid.h>         pid.h</a> </li>
<li><a href="./code/"regulate.h>    regulate.h</a> </li>
<li><a href="./code/"screen.c>      screen.c</a> </li>
<li><a href="./code/"screen.h>      screen.h</a> </li>    
</ul>
        <h3>Cost</h3>
	<style type="text/css">
	table.tableizer-table {
	border: 1px solid #CCC; font-family: Arial, Helvetica, sans-serif
	font-size: 12px;
} 
.tableizer-table td {
	padding: 4px;
	margin: 3px;
	border: 1px solid #CCC;
}
.tableizer-table th {
	background-color: #FDF9EB; 
	color: #FFF;
	font-weight: bold;
}
</style><table class="tableizer-table">
<tbody><tr class="tableizer-firstrow"><th>Part</th><th>Source</th>        <th> Unit Price </th>   <th>Quantity</th><th>Total Price</th></tr>
 <tr><td>Perf Board                     </td><td>Allelectronics</td>      <td> $1.50 </td>        <td>2</td>    <td> $3.00 </td></tr>
 <tr><td>500 Ohm Pot                    </td><td>Allelectronics</td>      <td> $0.50 </td>        <td>2</td>    <td> $1.00 </td></tr>
 <tr><td>10k ohm pot                    </td><td>Allelectronics</td>      <td> $2.00 </td>        <td>2</td>    <td> $4.00 </td></tr>
 <tr><td>74HC164N Shift Register        </td><td>Digikey</td>             <td> $0.43   </td>      <td>5</td>    <td> $2.15   </td></tr>
 <tr><td>LED Display                    </td><td>eBay</td>                <td> $1.80 </td>        <td>2</td>    <td> $3.60 </td></tr>
 <tr><td>Rice Cooker                    </td><td>Fry's Electronics</td>   <td> $34.99   </td>     <td>1</td>    <td> $34.99   </td></tr>
 <tr><td>Temperature sensor             </td><td>Digikey</td>             <td> $1.57   </td>      <td>1</td>    <td> $1.57   </td></tr>
 <tr><td>Gang Box                       </td><td>Lowes</td>               <td> $0.94   </td>      <td>1</td>    <td> $0.94   </td></tr>
 <tr><td>Combination Wall Plate         </td><td>Lowes</td>               <td> $0.88   </td>      <td>13</td    ><td> $0.88   </td></tr>
 <tr><td>Electrical Outlet              </td><td>Lowes</td>               <td> $0.59   </td>      <td>1</td>    <td> $0.59   </td></tr>
 <tr><td>Electrical Switch              </td><td>Lowes</td>               <td> $0.69   </td>      <td>1</td>    <td> $0.69   </td></tr>
 <tr><td>Sainsmart Relay module         </td><td>Amazon</td>              <td> $10.00   </td>     <td>1</td>    <td> $10.00   </td></tr>
 <tr><td>Microcontroller Atmage 1284P   </td><td>ECE 4760 Lab</td>        <td> $5.00   </td>       <td>1</td>    <td> $5.00   </td></tr>
 <tr><td>Piezoelectric Buzzer           </td><td>Chinasound</td>          <td> $1.62   </td>      <td>1</td>    <td> $1.62   </td></tr>
 <tr><td>Protoboard                     </td><td>ECE 4760 Lab</td>        <td> $6.00  </td>       <td>1</td>    <td> $6.00   </td></tr>
 <tr><td>Microcontroller PC Board       </td><td>ECE 4760 Lab</td>        <td> $7.00 </td>        <td>1</td    ><td> $7.00 </td></tr>
 <tr><td>Serial Connector               </td><td>ECE 4760 Lab</td>        <td> $1.00 </td>        <td>1</td>    <td> $1.00 </td></tr>
 <tr><td>Header Pins                    </td><td>ECE 4760 Lab</td>        <td> $0.05 </td>        <td>56</td>    <td> $2.80   </td></tr>
 <tr><td>DIP Switches                   </td><td>ECE 4760 Lab</td>        <td> $0.31 </td>       <td>2</td>    <td> $0.62 </td></tr>
 <tr><td>555 Timer                      </td><td>ECE 4760 Lab</td>        <td> $0.10 </td>       <td>1</td>    <td> $0.10 </td></tr>
 <tr><td>n-channel MOSFETs              </td><td>ECE 4760 Lab</td>        <td> $0.02 </td>       <td>2</td>    <td> $0.04 </td></tr>
 <tr><td>Plastic tubing                 </td><td>Scrap lying in Lab</td>  <td> $0.00 </td>       <td>6 in</td>    <td> $0.00 </td></tr>
 <tr><td>Wiring                         </td><td>ECE 4760 Lab</td>        <td> $0.00 </td>       <td>10 ft</td>    <td> $0.00 </td></tr>


 <tr class="tableizer-firstrow"><th>Total</th><th>&nbsp;</th><th>&nbsp;</th><th>&nbsp;</th><th>$87.59</th></tr>
</tbody></table>


        

	<h3>Division of Labor</h3>
         <table width="100%" border="1">
          <thead>
            <tr>
              <th><strong>Gary He</strong></th>
              <th><strong>Alex Maass</strong></th>
            </tr>
          </thead>
          <tbody>
            <tr class="row1">
              <td>Temperature probe design and assembly</td>
              <td>Cooker assembly</td>
            </tr>

            <tr class="row2">
             <td>Programming of temperature feedback loop</td>
             <td>Design and construction of LED display</td>
            </tr>


            <tr class="row1">
             <td>Integration of TRT &amp; UART program interfaces</td>
             <td>Software driver programming of LED display</td>
            </tr>

            <tr class="row2">
             <td>Software integration of temperature probe</td>
             <td>Design and construction of analog switches and dials</td>
            </tr>

            <tr class="row1">
              <td>Calibration of temperature probe and heating element</td>
             <td>Software integration of analog switches and dials</td>

            </tr>

            <tr class="row2">
             <td>Final system testing</td>
              <td>Final system testing</td>
            </tr>

          </tbody>
        </table>
            <p></p>
            <p></p>
            <p></p>
        
        
         <div class="linklist"> <a name="references"></a>
        <h2>References &nbsp;&nbsp;&nbsp;<font size="-1"><strong><a href="index.html">top</a></strong></font></h2>
        <p style="margin: 0 0 0.5em">This section provides links to external reference documents, code, and websites used throughout the project.</p>
<h4>References</h4>
<ul>
<li><a href="http://www.atmel.com/Images/8059s.pdf">Atmega 1284P Datasheet</a></li>
<li><a href="http://people.ece.cornell.edu/land/courses/ece4760/TinyRealTime/">TRT Kernel</a></li>
<li><a href="http://www.ieee.org/about/corporate/governance/p7-8.html">IEEE Code of Ethics</a></li>
<li><a href="http://www.thesunrain.com/Amazon/2%20relay%20board/2-ch%20relay%20module.pdf">Sainsmart Relay Schematic</a></li>
<li><a href="http://www.ehow.com/how_7805517_wire-two-gang-box.html">Gangbox Wiring Tutorial</a></li>
<li><a href="http://www.atmel.com/images/doc2558.pdf">PID Controller Information</a></li>
</ul>
      </div>

        
        </div>
        

        
           </div>
    <!-- end maincontent -->
  </div>
  <!-- end content -->
  <script type="text/javascript" async="" src="./ECE4760_cooker_files/ga.js"></script><script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-22818013-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
  <!-- content out -->
  <hr>
  <!-- footer in -->
  <div id="footerwrap">
    <div id="footer">
      <div id="copyright">
        <div class="copyright">©2013 Gary He &amp; Alex Maass</div>
        <div class="copyright">Style adapted with permission from Ian Purnell and Casey Mak</div>
        <div class="copyright">Layout ©2010 Cornell University</div>
      </div>
    </div>
    <!-- end footer -->
  </div>
  <!-- end footerwrap -->
  <!-- footer out -->
</div>
<!-- end wrapper -->


<embed type="application/x-shockwave-flash" width="0" height="0"></div></div></div></div><div style="position: fixed; top: 4px; right: 4px; color: black; background-color: rgb(255, 255, 128); font-family: &#39;Lucida Console&#39;, &#39;Courier New&#39;, Mono; text-align: right; max-width: 600px; font-size: 80%;"></div></body></html>